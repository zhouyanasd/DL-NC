# -*- coding: utf-8 -*-
"""
    The components generator based on the parameter
    decoded from optimizer.

:Author: Yan Zhou

:License: BSD 3-Clause, see LICENSE file.
"""


from Brian2_scripts.sim_brian_paper.sim_brian_paper_CoE.src.networks.components import *
from Brian2_scripts.sim_brian_paper.sim_brian_paper_CoE.src.config import *
from Brian2_scripts.sim_brian_paper.sim_brian_paper_CoE.src.core import *

from brian2 import *


class Generator_connection_matrix(BaseFunctions):
    """
    This class offers the connection matrix generation functions
    of four kinds of blocks and reservoir.

    Parameters
    ----------
    random_state: int, random state generated by np.random.
    """

    def __init__(self, random_state):
        super().__init__()
        self.random_state = random_state
        self.block_generator_type = {'random':self.generate_connection_matrix_random,
                                     'scale_free':self.generate_connection_matrix_scale_free,
                                     'circle':self.generate_connection_matrix_circle,
                                     'hierarchy':self.generate_connection_matrix_hierarchy}

    def generate_connection_matrix_random(self, N, p):
        '''
         Generate connection matrix of random block

         Parameters
         ----------
         N: int, number of neurons of the block.
         p: double, the connection probability between two neurons.
         '''

        connection_matrix_out, connection_matrix_in = [], []
        for node_pre in np.arange(N):
            for node_post in np.arange(N):
                if node_pre == node_post:
                    continue
                elif np.random.rand() <= p:
                    connection_matrix_out.append(node_pre)
                    connection_matrix_in.append(node_post)
                else:
                    continue
        return N, np.array([connection_matrix_out, connection_matrix_in])

    def generate_connection_matrix_scale_free(self, N, p_alpha, p_beta, p_gama):
        '''
         Generate connection matrix of scale_free block

         Parameters
         ----------
         N: int, number of neurons of the block.
         p_alpha, p_beta, p_gama: double, the connection probability between two neurons.
         '''

        alpha = p_alpha/(p_alpha+p_beta+p_gama)
        beta = p_beta/(p_alpha+p_beta+p_gama)
        gama = p_gama/(p_alpha+p_beta+p_gama)
        DSF = Direct_scale_free(final_nodes = N,  alpha = alpha, beta = beta, gama = gama,
                                init_nodes = 1, delta_in=1, delta_out = 1)
        DSF.generate_graph()
        connection_matrix_out, connection_matrix_in = DSF.o, DSF.i
        return N, np.array([connection_matrix_out, connection_matrix_in])

    def generate_connection_matrix_circle(self, N, p_forward, p_backward, p_threshold):
        '''
         Generate connection matrix of circle block.
         'circle' is the critical variate to mark the position of neurons.
         'circle' is extend as 'circle + circle' to connect the tail and head.

         Parameters
         ----------
         N: int, number of neurons of the block.
         p_forward, p_backward, p_threshold: double, the connection probability between two neurons.
         '''

        connection_matrix_out, connection_matrix_in = [], []
        nodes = np.arange(N)
        start = np.random.randint(0, N)
        circle = []
        for i in range(N):
            try:
                circle.append(nodes[start + i])
            except IndexError:
                circle.append(nodes[start + i -N])
        circle = circle + circle

        for index_pre, node_pre in enumerate(circle[:N]):
            for index_post, node_post in enumerate(circle[index_pre+1:N+index_pre+1]):
                distance = index_post
                decay = np.clip((N * p_threshold - distance - 1), 0.0, N) / (N * p_threshold - 1)
                if np.random.rand() <= p_forward * decay:
                    connection_matrix_out.append(node_pre)
                    connection_matrix_in.append(node_post)
                if np.random.rand() <= p_backward * decay:
                    connection_matrix_out.append(node_post)
                    connection_matrix_in.append(node_pre)
        return N, np.array([connection_matrix_out, connection_matrix_in])

    def generate_connection_matrix_hierarchy(self, N_i, N_h, N_o, p_out, p_in, decay):
        '''
         Generate connection matrix of hierarchy block.
         The hierarchy structure separate as three layer.

         Parameters
         ----------
         N_i, N_h, N_o: int, number of neurons of the block for different layer.
         p_out, p_in: double, the connection probability between two neurons.
         decay: double, the decay of connection probability.
         '''

        connection_matrix_out, connection_matrix_in = [], []
        nodes = np.arange(N_i + N_h + N_o)
        nodes_ = [nodes[:N_i], nodes[N_i:N_h + N_i], nodes[N_h + N_i:N_i + N_h + N_o]]
        p_out_ = [np.array([p_out] * N_i), np.array([p_out] * N_h), np.array([p_out] * N_o)]
        p_in_ = [np.array([p_in] * N_i), np.array([p_in] * N_h), np.array([p_in] * N_o)]
        circle = [0, 1, 2] + [0, 1, 2]
        for i in circle[:3]:
            nodes_mid, p_out_mid, p_in_mid = nodes_[circle[i]], p_out_[circle[i]], p_in_[circle[i]]
            nodes_pre, p_out_pre, p_in_pre = nodes_[circle[i - 1]], p_out_[circle[i - 1]], p_in_[circle[i - 1]]
            nodes_post, p_out_post, p_in_post = nodes_[circle[i + 1]], p_out_[circle[i + 1]], p_in_[circle[i + 1]]
            for out_mid_index, node in enumerate(nodes_mid):
                in_post, in_pre = p_in_post.argsort()[::-1], p_in_pre.argsort()[::-1]
                for in_post_index in in_post:
                    if np.random.rand() <= p_out_mid[out_mid_index] \
                            and np.random.rand() <= p_out_post[in_post_index]:
                        connection_matrix_out.append(node)
                        connection_matrix_in.append(nodes_post[in_post_index])
                        p_out_mid[out_mid_index] = p_out_mid[out_mid_index] * decay
                        p_in_post[in_post_index] = p_in_post[in_post_index] * decay
                for in_pre_index in in_pre:
                    if np.random.rand() <= p_out_mid[out_mid_index] \
                            and np.random.rand() <= p_out_pre[in_pre_index]:
                        connection_matrix_out.append(node)
                        connection_matrix_in.append(nodes_pre[in_pre_index])
                        p_out_mid[out_mid_index] = p_out_mid[out_mid_index] * decay
                        p_out_pre[in_pre_index] = p_out_pre[in_pre_index] * decay
        return N_i + N_h + N_o, np.array([connection_matrix_out, connection_matrix_in])

    def generate_connection_matrix_reservoir_layer(self, blocks_type, count, layer, structure_type, cmo, cmi):
        '''
         Generate connection matrix of reservoir for signal layer.
         This programme use recursion.

         Parameters
         ----------
         blocks_type: list, the existing block position in a basic block group.
                      A basic block group contain four block with different type decided by gen.
         count: int, the current number of neurons have been added in this reservoir.
                     it will help with the index of neurons.
         layer: int, the layer order.
         structure_type: tuple(list, list,...), the represent number of the structure of each layer.
         cmo: list, the 'connection_matrix[0]'.
         cmi: list, the 'connection_matrix[1]'.
         '''

        cmo_, cmi_ = cmo, cmi
        count_ = count
        blocks_type_ = blocks_type
        if layer > 0 :
            o, i = [],[]
            for gen in structure_type[layer]:
                component = structure_layer['components_' + str(gen)]
                blocks_type_, count_, cmo_, cmi_, o_, i_ = \
                    self.generate_connection_matrix_reservoir_layer(
                        blocks_type_, count_, layer-1, structure_type, cmo_, cmi_)
                for com_so, com_si in zip(component['structure'][0], component['structure'][1]):
                    for com_so_ in o_[com_so]:
                        for com_si_ in i_[com_si]:
                            cmo_.append(com_so_)
                            cmi_.append(com_si_)
                for com_o, com_i in zip(component['output_input'][0], component['output_input'][1]):
                    o.append(o_[com_o])
                    i.append(i_[com_i])
            return blocks_type_, count_, cmo_, cmi_, o, i
        else:
            o, i = [],[]
            for gen in structure_type[layer]:
                component = structure_layer['components_' + str(gen)]
                cmo_.extend(list(np.array(component['structure'][0]) + count_))
                cmi_.extend(list(np.array(component['structure'][1]) + count_))
                o.append(list(np.array(component['output_input'][0]) + count_))
                i.append(list(np.array(component['output_input'][1]) + count_))
                type = list(np.unique(component['structure'][0] + component['structure'][1]))
                count_ = count_ + len(type)
                blocks_type_.extend(type)
            return blocks_type_, count_, cmo_, cmi_, o, i

    def generate_connection_matrix_reservoir(self, structure_type):
        '''
         Generate connection matrix of reservoir, especially for the first four components of reservoir.
         This programme use recursion.

         Parameters
         ----------
         structure_type: tuple(list, list,...), the represent number of the structure of each layer.

         Example
         ----------
         structure_type = ([2, 0, 0, 1], [3, 3, 2, 3])
         '''

        connection_matrix_out, connection_matrix_in = [], []
        layer = len(structure_type)-1
        count = 0
        blocks_type = []
        o, i = [], []
        component = structure_reservoir['components']
        blocks_type, count, connection_matrix_out, connection_matrix_in, o_, i_ = \
            self.generate_connection_matrix_reservoir_layer(blocks_type, count, layer, structure_type,
                                                  connection_matrix_out, connection_matrix_in)
        for com_so, com_si in zip(component['structure'][0], component['structure'][1]):
            for com_so_ in o_[com_so]:
                for com_si_ in i_[com_si]:
                    connection_matrix_out.append(com_so_)
                    connection_matrix_in.append(com_si_)
        for com_o, com_i in zip(component['output_input'][0], component['output_input'][1]):
            o.extend(o_[com_o])
            i.extend(i_[com_i])
        return blocks_type, np.array([connection_matrix_out, connection_matrix_in]), o, i


class Generator(Generator_connection_matrix):
    """
    This class offers a basic generation functions of each components in network.

    Parameters
    ----------
    random_state: int, random state generated by np.random.
    """

    def __init__(self, random_state):
        super().__init__(random_state)

    def register_decoder(self, decoder):
        '''
         Add gen decoder to this generator.

         Parameters
         ----------
         decoder: Decoder, a instance of Decoder class.
         '''

        self.decoder = decoder

    def generate_block(self, name, get_parameter_structure, get_matrix):
        '''
         AA basic block generator function.

         Parameters
         ----------
         name: str, the pre name of the generated block.
         get_parameter_structure: function, the function of decoder.
         get_parameter_structure: function, the function of generator.
         '''

        parameter_structure = get_parameter_structure('structure')
        N, connect_matrix = get_matrix(**parameter_structure)
        block = Block(N, connect_matrix)
        block.create_neurons(dynamics_reservoir, threshold = threshold_reservoir, reset = reset_reservoir,
                             refractory = refractory_reservoir, name='block_' + name)
        block.create_synapse(dynamics_block_synapse_STDP, dynamics_block_synapse_pre_STDP,
                            dynamics_block_synapse_post_STDP, name='block_block_' + name)
        block.separate_ex_inh()
        block.connect()
        block.determine_input_output()
        return block

    def generate_pathway(self, name, pre_group, post_group, connection_matrix, model, model_pre, model_post):
        '''
         A basic pathway generator function between the block group.

         Parameters
         ----------
         name: str, the pre name of the generated synapses.
         pre_group: BlockGroup, the block group before the pathway.
         post_group: post_group, the block group after the pathway.
         connection_matrix: list[list[int], list[int]], the fixed connection matrix between 'Block_group',
                            int for 'Block'.
         '''

        pathway = Pathway(pre_group.blocks, post_group.blocks, connection_matrix)
        pathway.create_synapse(model, model_pre, model_post,  name = name)
        return pathway

    def generate_blocks(self, blocks_type):
        '''
         Generate blocks for reservoir according to blocks_type,
         the blocks belong to one block group.

         Parameters
         ----------
         blocks_type: list[int], the block type order according to 'structure_blocks'.
         '''

        block_group = BlockGroup()
        for index, type in enumerate(blocks_type):
            component = structure_blocks['components_' + str(type)]
            block_decoder = self.decoder.block_decoder_type[component]
            block_generator = self.block_generator_type[component]
            block = self.generate_block(component + '_' + str(index), block_decoder, block_generator)
            block_group.add_block(block, component)
        return block_group

    def generate_reservoir(self):
        '''
         Generate reservoir and thus generate the block group and pathway in it.

         Parameters
         ----------
         '''

        reservoir = Reservoir()
        block_type = self.decoder.get_reservoir_block_type()
        structure_type = self.decoder.get_reservoir_structure_type()
        blocks_type, connection_matrix, o, i = self.generate_connection_matrix_reservoir(structure_type)
        blocks_type = list(np.array(block_type)[blocks_type])
        block_group = self.generate_blocks(blocks_type)
        pathway = self.generate_pathway('pathway_reservoir_', block_group, block_group, connection_matrix,
                                        dynamics_reservoir_synapse_STDP, dynamics_reservoir_synapse_pre_STDP,
                                        dynamics_reservoir_synapse_post_STDP)
        pathway.connect()
        reservoir.register_blocks(block_group)
        reservoir.register_pathway(pathway)
        reservoir.register_input_output(o, i)
        return reservoir

    def generate_encoding(self):
        '''
         Generate a block group containing only one block as encoding layer.

         Parameters
         ----------
         '''

        block_group = BlockGroup()
        N = self.decoder.get_encoding_structure()
        block = Block(N, np.array([]).reshape(2,-1))
        block.create_neurons(dynamics_encoding, threshold='I > 0', reset = None,
                             refractory = 0 * ms , name='block_encoding')
        block.create_synapse('strength : 1', None,
                            None, name='block_block_encoding_0')
        block.determine_input_output()
        block_group.add_block(block, -1)
        return block_group

    def generate_readout(self, reservoir):
        '''
         Generate a block group containing only one block as readout layer.
         The number of neurons is based on the reservoir.

         Parameters
         ----------
         reservoir: Reservoir, a instance of Reservoir class.
         '''

        block_group = BlockGroup()
        N = reservoir.output_neurons_count
        block = Block(N, np.array([]).reshape(2,-1))
        block.create_neurons(dynamics_readout, threshold=None, reset = None,
                             refractory = False, name='block_readout')
        block.create_synapse('strength : 1', None,
                            None, name='block_block_readout_0')
        block.determine_input_output()
        block_group.add_block(block, -1)
        return block_group

    def generate_pathway_encoding_reservoir(self, encoding, reservoir):
        '''
         Generate pathway between the block group of encoding and the block group of reservoir.

         Parameters
         ----------
         encoding: BlockGroup, a instance of BlockGroup class only containing one Block as encoding layer.
         reservoir: Reservoir, a instance of Reservoir class.
         '''

        connection_matrix = [[0]*len(reservoir.input), reservoir.input]
        p_connection = self.decoder.get_parameters_encoding_readout('structure')['p_connection']
        pathway = self.generate_pathway('pathway_encoding_', encoding, reservoir.block_group, connection_matrix,
                                        dynamics_encoding_synapse_STDP, dynamics_encoding_synapse_pre_STDP,
                                        dynamics_encoding_synapse_post_STDP)
        pathway._set_connect_type('probability')
        pathway.connect(p_connection = p_connection)
        return pathway

    def generate_pathway_reservoir_readout(self, reservoir, readout):
        '''
         Generate pathway between the block group of readout and the block group of reservoir.

         Parameters
         ----------
         reservoir: Reservoir, a instance of Reservoir class.
         readout: BlockGroup, a instance of BlockGroup class only containing one Block as readout layer.
         '''

        connection_matrix = [reservoir.output, [0]*len(reservoir.output)]
        pathway = self.generate_pathway('pathway_readout_', reservoir.block_group, readout, connection_matrix,
                                        'strength = 1 : 1', dynamics_readout_synapse_pre, None)
        pathway._set_connect_type('one_to_one')
        pathway.connect()
        return pathway

    def generate_network(self):
        '''
         A comprehensive structure generation function of the LSM_Network.

         Parameters
         ----------
         '''

        network = LSM_Network()
        encoding = self.generate_encoding()
        reservoir = self.generate_reservoir()
        readout = self.generate_readout(reservoir)
        pathway_encoding_reservoir = self.generate_pathway_encoding_reservoir(encoding, reservoir)
        pathway_reservoir_readout = self.generate_pathway_reservoir_readout(reservoir, readout)

        network.register_layer(encoding, 'encoding')
        network.register_layer(reservoir, 'reservoir')
        network.register_layer(readout, 'readout')
        network.register_pathway(pathway_encoding_reservoir, 'encoding_reservoir')
        network.register_pathway(pathway_reservoir_readout, 'reservoir_readout')
        return network

    def initialize(self, network):
        '''
         Initialize the components of LSM_Network,
         it will call the function 'initialize' of LSM_Network.

         Parameters
         ----------
         network: LSM_Network, the instance of 'LSM_Network'.
         '''

        parameters = self.decoder.get_parameters_initialization()
        network.initialize(**parameters)

    def join(self, net, network):
        '''
         Join the network generated by generator into the 'Brain2.Network'.
         Only used after the LSM_Network generated,
         it will call the function 'join_network' of LSM_Network.

         Parameters
         ----------
         net: Brian2.Network, the existing neural network.
         network: LSM_Network, the instance of 'LSM_Network'.
         '''

        network.join_network(net)